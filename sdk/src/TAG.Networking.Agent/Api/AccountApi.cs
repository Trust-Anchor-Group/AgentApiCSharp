/*
 * Agent API
 *
 * The Neuron® publishes an Agent API that can be used by agents that do not wish to, or are able to, connect to the Neuron® via any of the XMPP bindings available, such as standard binary  socket, websocket or Synchronous HTTP (BOSH). Via the Agent API, the agent is permitted to do  basic tasks, such as send messages, create Agent IDs, and sign contracts with such Agent IDs.  The Full API is 
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using TAG.Networking.Agent.Client;
using TAG.Networking.Agent.Model;

namespace TAG.Networking.Agent.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAccountApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create Account
        /// </summary>
        /// <remarks>
        /// Creates an agent account on the server (and logs in to it). This account can be used  when logging in, using the Agent API, but also to connect to the Neuron(R) using any of  the available XMPP bindings available. The account that is created, is considered a  regular XMPP account on the broker.  When first created, the account is in a disabled state. You need to validate the e-mail address provided in the request first, before the account can be enabled. An e-mail with a verification code will be sent to the e-mail address provided in the request.  **Security Notice**: This resource requires an API Key and Secret to be provided. These are [requested from the operator]({domain}/RequestApiKey.md) and must be protected. If compromized, the operator can choose to disable the key. This resource should therefore only be used by clients that can protect such credentials. If creating  an account in an environment where protecting such credentials is not possible  (such as a web page running on a client browser), use the  [CreateWebForm]({domain}/CreateWebForm.md) resource instead. Each API Key is given a number  of accounts that can be created with that key. If that limit is reached, no more  accounts can be created using that key, until the limit is increased or existing accounts created by that API Key is deleted.  Input Parameters - -- -- -- -- -- -- -- -- --  | Parameter    | Description | |- -- -- -- -- -- --|- -- -- -- -- -- -| | &#x60;PUserName&#x60;  | User Name of the account to create. | | &#x60;PEMail&#x60;     | e-Mail address of the user. | | &#x60;PPassword&#x60;  | Password to use. | | &#x60;PApiKey&#x60;    | API Key to use, to get privileges to create an account. | | &#x60;PNonce&#x60;     | A unique random string, at least 32 characters long, with sufficient entropy to not be reused again. If reused, an error will be returned. | | &#x60;PSignature&#x60; | Cryptographic signature of request. | | &#x60;PSeconds&#x60;   | Requested number of seconds before the JWT token that will be issued expires. |  Response Parameters - -- -- -- -- -- -- -- -- -- -- --  | Parameter   | Description | |- -- -- -- -- -- -|- -- -- -- -- -- -| | &#x60;PCreated&#x60;  | When account was created (server timestamp). | | &#x60;PEnabled&#x60;  | If account is enabled or not. When creating an account, it&#39;s disabled by default, until the e-mail address has been validated. | | &#x60;PCanRelay&#x60; | If account can be used to relay e-mails. | | &#x60;PJwt&#x60;      | A token representing the login to the account. This token is seant as a [Bearer token](https://www.rfc-editor.org/rfc/rfc6750) in requests requiring authentication. | | &#x60;PExpires&#x60;  | When the JWT token expires. The token needs to be renewed before this token expires, if the client wishes to maintain the connection. After the token expires, the client needs to login again. |  **Note**: If trying to create an account that already exists, and that is enabled, but  using the same password as the existing account, and if PLAIN authentication is permitted on the server, the request will be treated as a login request. The timestamp of the  creation of the account can be seen in the response to the request.  Calculating Signature - -- -- -- -- -- -- -- -- -- -- -- -  The signature in &#x60;PSignature&#x60; is calculated as follows.  1. Concatenate the strings &#x60;PUserName \&quot;:\&quot; Host \&quot;:\&quot; PEMail \&quot;:\&quot; PPassword \&quot;:\&quot; PApiKey \&quot;:\&quot; PNonce&#x60; and call it &#x60;s&#x60;, where &#x60;Host&#x60; is the host/domain name of the server. It is taken from the HTTP &#x60;Host&#x60; request header, so it must be the same as is used in the URL of the request.  2. UTF-8 encode the *secret* corresponding to the API key, and call it &#x60;Key&#x60;.  3. UTF-8 encode the string &#x60;s&#x60;, and call it &#x60;Data&#x60;.  4. Calculate the HMAC-SHA256 signature using &#x60;Key&#x60; and &#x60;Data&#x60;, and call it &#x60;H&#x60;.  5. Base64-encode &#x60;H&#x60;. The result is the signature of the request.  Signature Audits - -- -- -- -- -- -- -- -- --  Signatures are audited. If too many failed signature attempts are received in a row from a given remote endpoint, that endpoint will be temporarily blocked from further attempts. Error message will contain a timestamp when new attempts can be made. If continuing failing, a remote endpoint may become permanently blocked from accessing the API.  Alternative Name Suggestions - -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  If unable to create an account, suggestions for alternative account names will be returned as HTTP headers, with header names &#x60;X-AlternativeNameN&#x60;, where N is a random number starting with &#x60;1&#x60;. Digits will be two or more digits. 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAccountBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CreateAccountResponse</returns>
        CreateAccountResponse CreateAccount(CreateAccountBody createAccountBody, int operationIndex = 0);

        /// <summary>
        /// Create Account
        /// </summary>
        /// <remarks>
        /// Creates an agent account on the server (and logs in to it). This account can be used  when logging in, using the Agent API, but also to connect to the Neuron(R) using any of  the available XMPP bindings available. The account that is created, is considered a  regular XMPP account on the broker.  When first created, the account is in a disabled state. You need to validate the e-mail address provided in the request first, before the account can be enabled. An e-mail with a verification code will be sent to the e-mail address provided in the request.  **Security Notice**: This resource requires an API Key and Secret to be provided. These are [requested from the operator]({domain}/RequestApiKey.md) and must be protected. If compromized, the operator can choose to disable the key. This resource should therefore only be used by clients that can protect such credentials. If creating  an account in an environment where protecting such credentials is not possible  (such as a web page running on a client browser), use the  [CreateWebForm]({domain}/CreateWebForm.md) resource instead. Each API Key is given a number  of accounts that can be created with that key. If that limit is reached, no more  accounts can be created using that key, until the limit is increased or existing accounts created by that API Key is deleted.  Input Parameters - -- -- -- -- -- -- -- -- --  | Parameter    | Description | |- -- -- -- -- -- --|- -- -- -- -- -- -| | &#x60;PUserName&#x60;  | User Name of the account to create. | | &#x60;PEMail&#x60;     | e-Mail address of the user. | | &#x60;PPassword&#x60;  | Password to use. | | &#x60;PApiKey&#x60;    | API Key to use, to get privileges to create an account. | | &#x60;PNonce&#x60;     | A unique random string, at least 32 characters long, with sufficient entropy to not be reused again. If reused, an error will be returned. | | &#x60;PSignature&#x60; | Cryptographic signature of request. | | &#x60;PSeconds&#x60;   | Requested number of seconds before the JWT token that will be issued expires. |  Response Parameters - -- -- -- -- -- -- -- -- -- -- --  | Parameter   | Description | |- -- -- -- -- -- -|- -- -- -- -- -- -| | &#x60;PCreated&#x60;  | When account was created (server timestamp). | | &#x60;PEnabled&#x60;  | If account is enabled or not. When creating an account, it&#39;s disabled by default, until the e-mail address has been validated. | | &#x60;PCanRelay&#x60; | If account can be used to relay e-mails. | | &#x60;PJwt&#x60;      | A token representing the login to the account. This token is seant as a [Bearer token](https://www.rfc-editor.org/rfc/rfc6750) in requests requiring authentication. | | &#x60;PExpires&#x60;  | When the JWT token expires. The token needs to be renewed before this token expires, if the client wishes to maintain the connection. After the token expires, the client needs to login again. |  **Note**: If trying to create an account that already exists, and that is enabled, but  using the same password as the existing account, and if PLAIN authentication is permitted on the server, the request will be treated as a login request. The timestamp of the  creation of the account can be seen in the response to the request.  Calculating Signature - -- -- -- -- -- -- -- -- -- -- -- -  The signature in &#x60;PSignature&#x60; is calculated as follows.  1. Concatenate the strings &#x60;PUserName \&quot;:\&quot; Host \&quot;:\&quot; PEMail \&quot;:\&quot; PPassword \&quot;:\&quot; PApiKey \&quot;:\&quot; PNonce&#x60; and call it &#x60;s&#x60;, where &#x60;Host&#x60; is the host/domain name of the server. It is taken from the HTTP &#x60;Host&#x60; request header, so it must be the same as is used in the URL of the request.  2. UTF-8 encode the *secret* corresponding to the API key, and call it &#x60;Key&#x60;.  3. UTF-8 encode the string &#x60;s&#x60;, and call it &#x60;Data&#x60;.  4. Calculate the HMAC-SHA256 signature using &#x60;Key&#x60; and &#x60;Data&#x60;, and call it &#x60;H&#x60;.  5. Base64-encode &#x60;H&#x60;. The result is the signature of the request.  Signature Audits - -- -- -- -- -- -- -- -- --  Signatures are audited. If too many failed signature attempts are received in a row from a given remote endpoint, that endpoint will be temporarily blocked from further attempts. Error message will contain a timestamp when new attempts can be made. If continuing failing, a remote endpoint may become permanently blocked from accessing the API.  Alternative Name Suggestions - -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  If unable to create an account, suggestions for alternative account names will be returned as HTTP headers, with header names &#x60;X-AlternativeNameN&#x60;, where N is a random number starting with &#x60;1&#x60;. Digits will be two or more digits. 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAccountBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CreateAccountResponse</returns>
        ApiResponse<CreateAccountResponse> CreateAccountWithHttpInfo(CreateAccountBody createAccountBody, int operationIndex = 0);
        /// <summary>
        /// Get Domain Info
        /// </summary>
        /// <remarks>
        /// Gets human-readable information about the domain of the server. The request can be made anonymously. No authentication is  required. This resource is typically called in the beginning of an on-boarding process,  where the user is given a choice to select service provider (i.e. domain). 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="acceptLanguage">The Accept-Language is used to select which language to use for human-readable strings returned. (optional, default to &quot;en&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DomainInfoResponse</returns>
        DomainInfoResponse GetDomainInfo(string acceptLanguage = default(string), int operationIndex = 0);

        /// <summary>
        /// Get Domain Info
        /// </summary>
        /// <remarks>
        /// Gets human-readable information about the domain of the server. The request can be made anonymously. No authentication is  required. This resource is typically called in the beginning of an on-boarding process,  where the user is given a choice to select service provider (i.e. domain). 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="acceptLanguage">The Accept-Language is used to select which language to use for human-readable strings returned. (optional, default to &quot;en&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DomainInfoResponse</returns>
        ApiResponse<DomainInfoResponse> GetDomainInfoWithHttpInfo(string acceptLanguage = default(string), int operationIndex = 0);
        /// <summary>
        /// Get newly created account created using a web form
        /// </summary>
        /// <remarks>
        /// Allows the client to get session information about a newly created account, created using a web form, without having to provide user credentials again.
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GetSessionTokenResponse</returns>
        GetSessionTokenResponse GetSessionToken(Object body = default(Object), int operationIndex = 0);

        /// <summary>
        /// Get newly created account created using a web form
        /// </summary>
        /// <remarks>
        /// Allows the client to get session information about a newly created account, created using a web form, without having to provide user credentials again.
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GetSessionTokenResponse</returns>
        ApiResponse<GetSessionTokenResponse> GetSessionTokenWithHttpInfo(Object body = default(Object), int operationIndex = 0);
        /// <summary>
        /// Login
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LoginResponse</returns>
        LoginResponse Login(LoginBody loginBody, int operationIndex = 0);

        /// <summary>
        /// Login
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LoginResponse</returns>
        ApiResponse<LoginResponse> LoginWithHttpInfo(LoginBody loginBody, int operationIndex = 0);
        /// <summary>
        /// Logout
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        Object Logout(Object body = default(Object), int operationIndex = 0);

        /// <summary>
        /// Logout
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> LogoutWithHttpInfo(Object body = default(Object), int operationIndex = 0);
        /// <summary>
        /// Recover Account
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recoverBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        Object Recover(RecoverBody recoverBody = default(RecoverBody), int operationIndex = 0);

        /// <summary>
        /// Recover Account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recoverBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> RecoverWithHttpInfo(RecoverBody recoverBody = default(RecoverBody), int operationIndex = 0);
        /// <summary>
        /// Refresh
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="refreshBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LoginResponse</returns>
        LoginResponse Refresh(RefreshBody refreshBody, int operationIndex = 0);

        /// <summary>
        /// Refresh
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="refreshBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LoginResponse</returns>
        ApiResponse<LoginResponse> RefreshWithHttpInfo(RefreshBody refreshBody, int operationIndex = 0);
        /// <summary>
        /// Verify E-Mail
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="verifyEMailBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>VerifyEMailResponse</returns>
        VerifyEMailResponse VerifyEMail(VerifyEMailBody verifyEMailBody, int operationIndex = 0);

        /// <summary>
        /// Verify E-Mail
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="verifyEMailBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of VerifyEMailResponse</returns>
        ApiResponse<VerifyEMailResponse> VerifyEMailWithHttpInfo(VerifyEMailBody verifyEMailBody, int operationIndex = 0);
        /// <summary>
        /// Login
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="wwwLoginBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LoginResponse</returns>
        LoginResponse WwwLogin(WwwLoginBody wwwLoginBody = default(WwwLoginBody), int operationIndex = 0);

        /// <summary>
        /// Login
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="wwwLoginBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LoginResponse</returns>
        ApiResponse<LoginResponse> WwwLoginWithHttpInfo(WwwLoginBody wwwLoginBody = default(WwwLoginBody), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAccountApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Create Account
        /// </summary>
        /// <remarks>
        /// Creates an agent account on the server (and logs in to it). This account can be used  when logging in, using the Agent API, but also to connect to the Neuron(R) using any of  the available XMPP bindings available. The account that is created, is considered a  regular XMPP account on the broker.  When first created, the account is in a disabled state. You need to validate the e-mail address provided in the request first, before the account can be enabled. An e-mail with a verification code will be sent to the e-mail address provided in the request.  **Security Notice**: This resource requires an API Key and Secret to be provided. These are [requested from the operator]({domain}/RequestApiKey.md) and must be protected. If compromized, the operator can choose to disable the key. This resource should therefore only be used by clients that can protect such credentials. If creating  an account in an environment where protecting such credentials is not possible  (such as a web page running on a client browser), use the  [CreateWebForm]({domain}/CreateWebForm.md) resource instead. Each API Key is given a number  of accounts that can be created with that key. If that limit is reached, no more  accounts can be created using that key, until the limit is increased or existing accounts created by that API Key is deleted.  Input Parameters - -- -- -- -- -- -- -- -- --  | Parameter    | Description | |- -- -- -- -- -- --|- -- -- -- -- -- -| | &#x60;PUserName&#x60;  | User Name of the account to create. | | &#x60;PEMail&#x60;     | e-Mail address of the user. | | &#x60;PPassword&#x60;  | Password to use. | | &#x60;PApiKey&#x60;    | API Key to use, to get privileges to create an account. | | &#x60;PNonce&#x60;     | A unique random string, at least 32 characters long, with sufficient entropy to not be reused again. If reused, an error will be returned. | | &#x60;PSignature&#x60; | Cryptographic signature of request. | | &#x60;PSeconds&#x60;   | Requested number of seconds before the JWT token that will be issued expires. |  Response Parameters - -- -- -- -- -- -- -- -- -- -- --  | Parameter   | Description | |- -- -- -- -- -- -|- -- -- -- -- -- -| | &#x60;PCreated&#x60;  | When account was created (server timestamp). | | &#x60;PEnabled&#x60;  | If account is enabled or not. When creating an account, it&#39;s disabled by default, until the e-mail address has been validated. | | &#x60;PCanRelay&#x60; | If account can be used to relay e-mails. | | &#x60;PJwt&#x60;      | A token representing the login to the account. This token is seant as a [Bearer token](https://www.rfc-editor.org/rfc/rfc6750) in requests requiring authentication. | | &#x60;PExpires&#x60;  | When the JWT token expires. The token needs to be renewed before this token expires, if the client wishes to maintain the connection. After the token expires, the client needs to login again. |  **Note**: If trying to create an account that already exists, and that is enabled, but  using the same password as the existing account, and if PLAIN authentication is permitted on the server, the request will be treated as a login request. The timestamp of the  creation of the account can be seen in the response to the request.  Calculating Signature - -- -- -- -- -- -- -- -- -- -- -- -  The signature in &#x60;PSignature&#x60; is calculated as follows.  1. Concatenate the strings &#x60;PUserName \&quot;:\&quot; Host \&quot;:\&quot; PEMail \&quot;:\&quot; PPassword \&quot;:\&quot; PApiKey \&quot;:\&quot; PNonce&#x60; and call it &#x60;s&#x60;, where &#x60;Host&#x60; is the host/domain name of the server. It is taken from the HTTP &#x60;Host&#x60; request header, so it must be the same as is used in the URL of the request.  2. UTF-8 encode the *secret* corresponding to the API key, and call it &#x60;Key&#x60;.  3. UTF-8 encode the string &#x60;s&#x60;, and call it &#x60;Data&#x60;.  4. Calculate the HMAC-SHA256 signature using &#x60;Key&#x60; and &#x60;Data&#x60;, and call it &#x60;H&#x60;.  5. Base64-encode &#x60;H&#x60;. The result is the signature of the request.  Signature Audits - -- -- -- -- -- -- -- -- --  Signatures are audited. If too many failed signature attempts are received in a row from a given remote endpoint, that endpoint will be temporarily blocked from further attempts. Error message will contain a timestamp when new attempts can be made. If continuing failing, a remote endpoint may become permanently blocked from accessing the API.  Alternative Name Suggestions - -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  If unable to create an account, suggestions for alternative account names will be returned as HTTP headers, with header names &#x60;X-AlternativeNameN&#x60;, where N is a random number starting with &#x60;1&#x60;. Digits will be two or more digits. 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAccountBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateAccountResponse</returns>
        System.Threading.Tasks.Task<CreateAccountResponse> CreateAccountAsync(CreateAccountBody createAccountBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create Account
        /// </summary>
        /// <remarks>
        /// Creates an agent account on the server (and logs in to it). This account can be used  when logging in, using the Agent API, but also to connect to the Neuron(R) using any of  the available XMPP bindings available. The account that is created, is considered a  regular XMPP account on the broker.  When first created, the account is in a disabled state. You need to validate the e-mail address provided in the request first, before the account can be enabled. An e-mail with a verification code will be sent to the e-mail address provided in the request.  **Security Notice**: This resource requires an API Key and Secret to be provided. These are [requested from the operator]({domain}/RequestApiKey.md) and must be protected. If compromized, the operator can choose to disable the key. This resource should therefore only be used by clients that can protect such credentials. If creating  an account in an environment where protecting such credentials is not possible  (such as a web page running on a client browser), use the  [CreateWebForm]({domain}/CreateWebForm.md) resource instead. Each API Key is given a number  of accounts that can be created with that key. If that limit is reached, no more  accounts can be created using that key, until the limit is increased or existing accounts created by that API Key is deleted.  Input Parameters - -- -- -- -- -- -- -- -- --  | Parameter    | Description | |- -- -- -- -- -- --|- -- -- -- -- -- -| | &#x60;PUserName&#x60;  | User Name of the account to create. | | &#x60;PEMail&#x60;     | e-Mail address of the user. | | &#x60;PPassword&#x60;  | Password to use. | | &#x60;PApiKey&#x60;    | API Key to use, to get privileges to create an account. | | &#x60;PNonce&#x60;     | A unique random string, at least 32 characters long, with sufficient entropy to not be reused again. If reused, an error will be returned. | | &#x60;PSignature&#x60; | Cryptographic signature of request. | | &#x60;PSeconds&#x60;   | Requested number of seconds before the JWT token that will be issued expires. |  Response Parameters - -- -- -- -- -- -- -- -- -- -- --  | Parameter   | Description | |- -- -- -- -- -- -|- -- -- -- -- -- -| | &#x60;PCreated&#x60;  | When account was created (server timestamp). | | &#x60;PEnabled&#x60;  | If account is enabled or not. When creating an account, it&#39;s disabled by default, until the e-mail address has been validated. | | &#x60;PCanRelay&#x60; | If account can be used to relay e-mails. | | &#x60;PJwt&#x60;      | A token representing the login to the account. This token is seant as a [Bearer token](https://www.rfc-editor.org/rfc/rfc6750) in requests requiring authentication. | | &#x60;PExpires&#x60;  | When the JWT token expires. The token needs to be renewed before this token expires, if the client wishes to maintain the connection. After the token expires, the client needs to login again. |  **Note**: If trying to create an account that already exists, and that is enabled, but  using the same password as the existing account, and if PLAIN authentication is permitted on the server, the request will be treated as a login request. The timestamp of the  creation of the account can be seen in the response to the request.  Calculating Signature - -- -- -- -- -- -- -- -- -- -- -- -  The signature in &#x60;PSignature&#x60; is calculated as follows.  1. Concatenate the strings &#x60;PUserName \&quot;:\&quot; Host \&quot;:\&quot; PEMail \&quot;:\&quot; PPassword \&quot;:\&quot; PApiKey \&quot;:\&quot; PNonce&#x60; and call it &#x60;s&#x60;, where &#x60;Host&#x60; is the host/domain name of the server. It is taken from the HTTP &#x60;Host&#x60; request header, so it must be the same as is used in the URL of the request.  2. UTF-8 encode the *secret* corresponding to the API key, and call it &#x60;Key&#x60;.  3. UTF-8 encode the string &#x60;s&#x60;, and call it &#x60;Data&#x60;.  4. Calculate the HMAC-SHA256 signature using &#x60;Key&#x60; and &#x60;Data&#x60;, and call it &#x60;H&#x60;.  5. Base64-encode &#x60;H&#x60;. The result is the signature of the request.  Signature Audits - -- -- -- -- -- -- -- -- --  Signatures are audited. If too many failed signature attempts are received in a row from a given remote endpoint, that endpoint will be temporarily blocked from further attempts. Error message will contain a timestamp when new attempts can be made. If continuing failing, a remote endpoint may become permanently blocked from accessing the API.  Alternative Name Suggestions - -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  If unable to create an account, suggestions for alternative account names will be returned as HTTP headers, with header names &#x60;X-AlternativeNameN&#x60;, where N is a random number starting with &#x60;1&#x60;. Digits will be two or more digits. 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAccountBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateAccountResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateAccountResponse>> CreateAccountWithHttpInfoAsync(CreateAccountBody createAccountBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Domain Info
        /// </summary>
        /// <remarks>
        /// Gets human-readable information about the domain of the server. The request can be made anonymously. No authentication is  required. This resource is typically called in the beginning of an on-boarding process,  where the user is given a choice to select service provider (i.e. domain). 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="acceptLanguage">The Accept-Language is used to select which language to use for human-readable strings returned. (optional, default to &quot;en&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DomainInfoResponse</returns>
        System.Threading.Tasks.Task<DomainInfoResponse> GetDomainInfoAsync(string acceptLanguage = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Domain Info
        /// </summary>
        /// <remarks>
        /// Gets human-readable information about the domain of the server. The request can be made anonymously. No authentication is  required. This resource is typically called in the beginning of an on-boarding process,  where the user is given a choice to select service provider (i.e. domain). 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="acceptLanguage">The Accept-Language is used to select which language to use for human-readable strings returned. (optional, default to &quot;en&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DomainInfoResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DomainInfoResponse>> GetDomainInfoWithHttpInfoAsync(string acceptLanguage = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get newly created account created using a web form
        /// </summary>
        /// <remarks>
        /// Allows the client to get session information about a newly created account, created using a web form, without having to provide user credentials again.
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetSessionTokenResponse</returns>
        System.Threading.Tasks.Task<GetSessionTokenResponse> GetSessionTokenAsync(Object body = default(Object), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get newly created account created using a web form
        /// </summary>
        /// <remarks>
        /// Allows the client to get session information about a newly created account, created using a web form, without having to provide user credentials again.
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetSessionTokenResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetSessionTokenResponse>> GetSessionTokenWithHttpInfoAsync(Object body = default(Object), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Login
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LoginResponse</returns>
        System.Threading.Tasks.Task<LoginResponse> LoginAsync(LoginBody loginBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Login
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LoginResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<LoginResponse>> LoginWithHttpInfoAsync(LoginBody loginBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Logout
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> LogoutAsync(Object body = default(Object), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Logout
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> LogoutWithHttpInfoAsync(Object body = default(Object), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Recover Account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recoverBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> RecoverAsync(RecoverBody recoverBody = default(RecoverBody), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Recover Account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recoverBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RecoverWithHttpInfoAsync(RecoverBody recoverBody = default(RecoverBody), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Refresh
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="refreshBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LoginResponse</returns>
        System.Threading.Tasks.Task<LoginResponse> RefreshAsync(RefreshBody refreshBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Refresh
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="refreshBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LoginResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<LoginResponse>> RefreshWithHttpInfoAsync(RefreshBody refreshBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Verify E-Mail
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="verifyEMailBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VerifyEMailResponse</returns>
        System.Threading.Tasks.Task<VerifyEMailResponse> VerifyEMailAsync(VerifyEMailBody verifyEMailBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Verify E-Mail
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="verifyEMailBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VerifyEMailResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<VerifyEMailResponse>> VerifyEMailWithHttpInfoAsync(VerifyEMailBody verifyEMailBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Login
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="wwwLoginBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LoginResponse</returns>
        System.Threading.Tasks.Task<LoginResponse> WwwLoginAsync(WwwLoginBody wwwLoginBody = default(WwwLoginBody), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Login
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="wwwLoginBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LoginResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<LoginResponse>> WwwLoginWithHttpInfoAsync(WwwLoginBody wwwLoginBody = default(WwwLoginBody), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAccountApi : IAccountApiSync, IAccountApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class AccountApi : IAccountApi
    {
        private TAG.Networking.Agent.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="AccountApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AccountApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AccountApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AccountApi(string basePath)
        {
            this.Configuration = TAG.Networking.Agent.Client.Configuration.MergeConfigurations(
                TAG.Networking.Agent.Client.GlobalConfiguration.Instance,
                new TAG.Networking.Agent.Client.Configuration { BasePath = basePath }
            );
            this.Client = new TAG.Networking.Agent.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new TAG.Networking.Agent.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = TAG.Networking.Agent.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AccountApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public AccountApi(TAG.Networking.Agent.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = TAG.Networking.Agent.Client.Configuration.MergeConfigurations(
                TAG.Networking.Agent.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new TAG.Networking.Agent.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new TAG.Networking.Agent.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = TAG.Networking.Agent.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AccountApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public AccountApi(TAG.Networking.Agent.Client.ISynchronousClient client, TAG.Networking.Agent.Client.IAsynchronousClient asyncClient, TAG.Networking.Agent.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = TAG.Networking.Agent.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public TAG.Networking.Agent.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public TAG.Networking.Agent.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public TAG.Networking.Agent.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public TAG.Networking.Agent.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Create Account Creates an agent account on the server (and logs in to it). This account can be used  when logging in, using the Agent API, but also to connect to the Neuron(R) using any of  the available XMPP bindings available. The account that is created, is considered a  regular XMPP account on the broker.  When first created, the account is in a disabled state. You need to validate the e-mail address provided in the request first, before the account can be enabled. An e-mail with a verification code will be sent to the e-mail address provided in the request.  **Security Notice**: This resource requires an API Key and Secret to be provided. These are [requested from the operator]({domain}/RequestApiKey.md) and must be protected. If compromized, the operator can choose to disable the key. This resource should therefore only be used by clients that can protect such credentials. If creating  an account in an environment where protecting such credentials is not possible  (such as a web page running on a client browser), use the  [CreateWebForm]({domain}/CreateWebForm.md) resource instead. Each API Key is given a number  of accounts that can be created with that key. If that limit is reached, no more  accounts can be created using that key, until the limit is increased or existing accounts created by that API Key is deleted.  Input Parameters - -- -- -- -- -- -- -- -- --  | Parameter    | Description | |- -- -- -- -- -- --|- -- -- -- -- -- -| | &#x60;PUserName&#x60;  | User Name of the account to create. | | &#x60;PEMail&#x60;     | e-Mail address of the user. | | &#x60;PPassword&#x60;  | Password to use. | | &#x60;PApiKey&#x60;    | API Key to use, to get privileges to create an account. | | &#x60;PNonce&#x60;     | A unique random string, at least 32 characters long, with sufficient entropy to not be reused again. If reused, an error will be returned. | | &#x60;PSignature&#x60; | Cryptographic signature of request. | | &#x60;PSeconds&#x60;   | Requested number of seconds before the JWT token that will be issued expires. |  Response Parameters - -- -- -- -- -- -- -- -- -- -- --  | Parameter   | Description | |- -- -- -- -- -- -|- -- -- -- -- -- -| | &#x60;PCreated&#x60;  | When account was created (server timestamp). | | &#x60;PEnabled&#x60;  | If account is enabled or not. When creating an account, it&#39;s disabled by default, until the e-mail address has been validated. | | &#x60;PCanRelay&#x60; | If account can be used to relay e-mails. | | &#x60;PJwt&#x60;      | A token representing the login to the account. This token is seant as a [Bearer token](https://www.rfc-editor.org/rfc/rfc6750) in requests requiring authentication. | | &#x60;PExpires&#x60;  | When the JWT token expires. The token needs to be renewed before this token expires, if the client wishes to maintain the connection. After the token expires, the client needs to login again. |  **Note**: If trying to create an account that already exists, and that is enabled, but  using the same password as the existing account, and if PLAIN authentication is permitted on the server, the request will be treated as a login request. The timestamp of the  creation of the account can be seen in the response to the request.  Calculating Signature - -- -- -- -- -- -- -- -- -- -- -- -  The signature in &#x60;PSignature&#x60; is calculated as follows.  1. Concatenate the strings &#x60;PUserName \&quot;:\&quot; Host \&quot;:\&quot; PEMail \&quot;:\&quot; PPassword \&quot;:\&quot; PApiKey \&quot;:\&quot; PNonce&#x60; and call it &#x60;s&#x60;, where &#x60;Host&#x60; is the host/domain name of the server. It is taken from the HTTP &#x60;Host&#x60; request header, so it must be the same as is used in the URL of the request.  2. UTF-8 encode the *secret* corresponding to the API key, and call it &#x60;Key&#x60;.  3. UTF-8 encode the string &#x60;s&#x60;, and call it &#x60;Data&#x60;.  4. Calculate the HMAC-SHA256 signature using &#x60;Key&#x60; and &#x60;Data&#x60;, and call it &#x60;H&#x60;.  5. Base64-encode &#x60;H&#x60;. The result is the signature of the request.  Signature Audits - -- -- -- -- -- -- -- -- --  Signatures are audited. If too many failed signature attempts are received in a row from a given remote endpoint, that endpoint will be temporarily blocked from further attempts. Error message will contain a timestamp when new attempts can be made. If continuing failing, a remote endpoint may become permanently blocked from accessing the API.  Alternative Name Suggestions - -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  If unable to create an account, suggestions for alternative account names will be returned as HTTP headers, with header names &#x60;X-AlternativeNameN&#x60;, where N is a random number starting with &#x60;1&#x60;. Digits will be two or more digits. 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAccountBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CreateAccountResponse</returns>
        public CreateAccountResponse CreateAccount(CreateAccountBody createAccountBody, int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.ApiResponse<CreateAccountResponse> localVarResponse = CreateAccountWithHttpInfo(createAccountBody);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create Account Creates an agent account on the server (and logs in to it). This account can be used  when logging in, using the Agent API, but also to connect to the Neuron(R) using any of  the available XMPP bindings available. The account that is created, is considered a  regular XMPP account on the broker.  When first created, the account is in a disabled state. You need to validate the e-mail address provided in the request first, before the account can be enabled. An e-mail with a verification code will be sent to the e-mail address provided in the request.  **Security Notice**: This resource requires an API Key and Secret to be provided. These are [requested from the operator]({domain}/RequestApiKey.md) and must be protected. If compromized, the operator can choose to disable the key. This resource should therefore only be used by clients that can protect such credentials. If creating  an account in an environment where protecting such credentials is not possible  (such as a web page running on a client browser), use the  [CreateWebForm]({domain}/CreateWebForm.md) resource instead. Each API Key is given a number  of accounts that can be created with that key. If that limit is reached, no more  accounts can be created using that key, until the limit is increased or existing accounts created by that API Key is deleted.  Input Parameters - -- -- -- -- -- -- -- -- --  | Parameter    | Description | |- -- -- -- -- -- --|- -- -- -- -- -- -| | &#x60;PUserName&#x60;  | User Name of the account to create. | | &#x60;PEMail&#x60;     | e-Mail address of the user. | | &#x60;PPassword&#x60;  | Password to use. | | &#x60;PApiKey&#x60;    | API Key to use, to get privileges to create an account. | | &#x60;PNonce&#x60;     | A unique random string, at least 32 characters long, with sufficient entropy to not be reused again. If reused, an error will be returned. | | &#x60;PSignature&#x60; | Cryptographic signature of request. | | &#x60;PSeconds&#x60;   | Requested number of seconds before the JWT token that will be issued expires. |  Response Parameters - -- -- -- -- -- -- -- -- -- -- --  | Parameter   | Description | |- -- -- -- -- -- -|- -- -- -- -- -- -| | &#x60;PCreated&#x60;  | When account was created (server timestamp). | | &#x60;PEnabled&#x60;  | If account is enabled or not. When creating an account, it&#39;s disabled by default, until the e-mail address has been validated. | | &#x60;PCanRelay&#x60; | If account can be used to relay e-mails. | | &#x60;PJwt&#x60;      | A token representing the login to the account. This token is seant as a [Bearer token](https://www.rfc-editor.org/rfc/rfc6750) in requests requiring authentication. | | &#x60;PExpires&#x60;  | When the JWT token expires. The token needs to be renewed before this token expires, if the client wishes to maintain the connection. After the token expires, the client needs to login again. |  **Note**: If trying to create an account that already exists, and that is enabled, but  using the same password as the existing account, and if PLAIN authentication is permitted on the server, the request will be treated as a login request. The timestamp of the  creation of the account can be seen in the response to the request.  Calculating Signature - -- -- -- -- -- -- -- -- -- -- -- -  The signature in &#x60;PSignature&#x60; is calculated as follows.  1. Concatenate the strings &#x60;PUserName \&quot;:\&quot; Host \&quot;:\&quot; PEMail \&quot;:\&quot; PPassword \&quot;:\&quot; PApiKey \&quot;:\&quot; PNonce&#x60; and call it &#x60;s&#x60;, where &#x60;Host&#x60; is the host/domain name of the server. It is taken from the HTTP &#x60;Host&#x60; request header, so it must be the same as is used in the URL of the request.  2. UTF-8 encode the *secret* corresponding to the API key, and call it &#x60;Key&#x60;.  3. UTF-8 encode the string &#x60;s&#x60;, and call it &#x60;Data&#x60;.  4. Calculate the HMAC-SHA256 signature using &#x60;Key&#x60; and &#x60;Data&#x60;, and call it &#x60;H&#x60;.  5. Base64-encode &#x60;H&#x60;. The result is the signature of the request.  Signature Audits - -- -- -- -- -- -- -- -- --  Signatures are audited. If too many failed signature attempts are received in a row from a given remote endpoint, that endpoint will be temporarily blocked from further attempts. Error message will contain a timestamp when new attempts can be made. If continuing failing, a remote endpoint may become permanently blocked from accessing the API.  Alternative Name Suggestions - -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  If unable to create an account, suggestions for alternative account names will be returned as HTTP headers, with header names &#x60;X-AlternativeNameN&#x60;, where N is a random number starting with &#x60;1&#x60;. Digits will be two or more digits. 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAccountBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CreateAccountResponse</returns>
        public TAG.Networking.Agent.Client.ApiResponse<CreateAccountResponse> CreateAccountWithHttpInfo(CreateAccountBody createAccountBody, int operationIndex = 0)
        {
            // verify the required parameter 'createAccountBody' is set
            if (createAccountBody == null)
            {
                throw new TAG.Networking.Agent.Client.ApiException(400, "Missing required parameter 'createAccountBody' when calling AccountApi->CreateAccount");
            }

            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createAccountBody;

            localVarRequestOptions.Operation = "AccountApi.CreateAccount";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<CreateAccountResponse>("/Agent/Account/Create", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAccount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create Account Creates an agent account on the server (and logs in to it). This account can be used  when logging in, using the Agent API, but also to connect to the Neuron(R) using any of  the available XMPP bindings available. The account that is created, is considered a  regular XMPP account on the broker.  When first created, the account is in a disabled state. You need to validate the e-mail address provided in the request first, before the account can be enabled. An e-mail with a verification code will be sent to the e-mail address provided in the request.  **Security Notice**: This resource requires an API Key and Secret to be provided. These are [requested from the operator]({domain}/RequestApiKey.md) and must be protected. If compromized, the operator can choose to disable the key. This resource should therefore only be used by clients that can protect such credentials. If creating  an account in an environment where protecting such credentials is not possible  (such as a web page running on a client browser), use the  [CreateWebForm]({domain}/CreateWebForm.md) resource instead. Each API Key is given a number  of accounts that can be created with that key. If that limit is reached, no more  accounts can be created using that key, until the limit is increased or existing accounts created by that API Key is deleted.  Input Parameters - -- -- -- -- -- -- -- -- --  | Parameter    | Description | |- -- -- -- -- -- --|- -- -- -- -- -- -| | &#x60;PUserName&#x60;  | User Name of the account to create. | | &#x60;PEMail&#x60;     | e-Mail address of the user. | | &#x60;PPassword&#x60;  | Password to use. | | &#x60;PApiKey&#x60;    | API Key to use, to get privileges to create an account. | | &#x60;PNonce&#x60;     | A unique random string, at least 32 characters long, with sufficient entropy to not be reused again. If reused, an error will be returned. | | &#x60;PSignature&#x60; | Cryptographic signature of request. | | &#x60;PSeconds&#x60;   | Requested number of seconds before the JWT token that will be issued expires. |  Response Parameters - -- -- -- -- -- -- -- -- -- -- --  | Parameter   | Description | |- -- -- -- -- -- -|- -- -- -- -- -- -| | &#x60;PCreated&#x60;  | When account was created (server timestamp). | | &#x60;PEnabled&#x60;  | If account is enabled or not. When creating an account, it&#39;s disabled by default, until the e-mail address has been validated. | | &#x60;PCanRelay&#x60; | If account can be used to relay e-mails. | | &#x60;PJwt&#x60;      | A token representing the login to the account. This token is seant as a [Bearer token](https://www.rfc-editor.org/rfc/rfc6750) in requests requiring authentication. | | &#x60;PExpires&#x60;  | When the JWT token expires. The token needs to be renewed before this token expires, if the client wishes to maintain the connection. After the token expires, the client needs to login again. |  **Note**: If trying to create an account that already exists, and that is enabled, but  using the same password as the existing account, and if PLAIN authentication is permitted on the server, the request will be treated as a login request. The timestamp of the  creation of the account can be seen in the response to the request.  Calculating Signature - -- -- -- -- -- -- -- -- -- -- -- -  The signature in &#x60;PSignature&#x60; is calculated as follows.  1. Concatenate the strings &#x60;PUserName \&quot;:\&quot; Host \&quot;:\&quot; PEMail \&quot;:\&quot; PPassword \&quot;:\&quot; PApiKey \&quot;:\&quot; PNonce&#x60; and call it &#x60;s&#x60;, where &#x60;Host&#x60; is the host/domain name of the server. It is taken from the HTTP &#x60;Host&#x60; request header, so it must be the same as is used in the URL of the request.  2. UTF-8 encode the *secret* corresponding to the API key, and call it &#x60;Key&#x60;.  3. UTF-8 encode the string &#x60;s&#x60;, and call it &#x60;Data&#x60;.  4. Calculate the HMAC-SHA256 signature using &#x60;Key&#x60; and &#x60;Data&#x60;, and call it &#x60;H&#x60;.  5. Base64-encode &#x60;H&#x60;. The result is the signature of the request.  Signature Audits - -- -- -- -- -- -- -- -- --  Signatures are audited. If too many failed signature attempts are received in a row from a given remote endpoint, that endpoint will be temporarily blocked from further attempts. Error message will contain a timestamp when new attempts can be made. If continuing failing, a remote endpoint may become permanently blocked from accessing the API.  Alternative Name Suggestions - -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  If unable to create an account, suggestions for alternative account names will be returned as HTTP headers, with header names &#x60;X-AlternativeNameN&#x60;, where N is a random number starting with &#x60;1&#x60;. Digits will be two or more digits. 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAccountBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateAccountResponse</returns>
        public async System.Threading.Tasks.Task<CreateAccountResponse> CreateAccountAsync(CreateAccountBody createAccountBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            TAG.Networking.Agent.Client.ApiResponse<CreateAccountResponse> localVarResponse = await CreateAccountWithHttpInfoAsync(createAccountBody, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create Account Creates an agent account on the server (and logs in to it). This account can be used  when logging in, using the Agent API, but also to connect to the Neuron(R) using any of  the available XMPP bindings available. The account that is created, is considered a  regular XMPP account on the broker.  When first created, the account is in a disabled state. You need to validate the e-mail address provided in the request first, before the account can be enabled. An e-mail with a verification code will be sent to the e-mail address provided in the request.  **Security Notice**: This resource requires an API Key and Secret to be provided. These are [requested from the operator]({domain}/RequestApiKey.md) and must be protected. If compromized, the operator can choose to disable the key. This resource should therefore only be used by clients that can protect such credentials. If creating  an account in an environment where protecting such credentials is not possible  (such as a web page running on a client browser), use the  [CreateWebForm]({domain}/CreateWebForm.md) resource instead. Each API Key is given a number  of accounts that can be created with that key. If that limit is reached, no more  accounts can be created using that key, until the limit is increased or existing accounts created by that API Key is deleted.  Input Parameters - -- -- -- -- -- -- -- -- --  | Parameter    | Description | |- -- -- -- -- -- --|- -- -- -- -- -- -| | &#x60;PUserName&#x60;  | User Name of the account to create. | | &#x60;PEMail&#x60;     | e-Mail address of the user. | | &#x60;PPassword&#x60;  | Password to use. | | &#x60;PApiKey&#x60;    | API Key to use, to get privileges to create an account. | | &#x60;PNonce&#x60;     | A unique random string, at least 32 characters long, with sufficient entropy to not be reused again. If reused, an error will be returned. | | &#x60;PSignature&#x60; | Cryptographic signature of request. | | &#x60;PSeconds&#x60;   | Requested number of seconds before the JWT token that will be issued expires. |  Response Parameters - -- -- -- -- -- -- -- -- -- -- --  | Parameter   | Description | |- -- -- -- -- -- -|- -- -- -- -- -- -| | &#x60;PCreated&#x60;  | When account was created (server timestamp). | | &#x60;PEnabled&#x60;  | If account is enabled or not. When creating an account, it&#39;s disabled by default, until the e-mail address has been validated. | | &#x60;PCanRelay&#x60; | If account can be used to relay e-mails. | | &#x60;PJwt&#x60;      | A token representing the login to the account. This token is seant as a [Bearer token](https://www.rfc-editor.org/rfc/rfc6750) in requests requiring authentication. | | &#x60;PExpires&#x60;  | When the JWT token expires. The token needs to be renewed before this token expires, if the client wishes to maintain the connection. After the token expires, the client needs to login again. |  **Note**: If trying to create an account that already exists, and that is enabled, but  using the same password as the existing account, and if PLAIN authentication is permitted on the server, the request will be treated as a login request. The timestamp of the  creation of the account can be seen in the response to the request.  Calculating Signature - -- -- -- -- -- -- -- -- -- -- -- -  The signature in &#x60;PSignature&#x60; is calculated as follows.  1. Concatenate the strings &#x60;PUserName \&quot;:\&quot; Host \&quot;:\&quot; PEMail \&quot;:\&quot; PPassword \&quot;:\&quot; PApiKey \&quot;:\&quot; PNonce&#x60; and call it &#x60;s&#x60;, where &#x60;Host&#x60; is the host/domain name of the server. It is taken from the HTTP &#x60;Host&#x60; request header, so it must be the same as is used in the URL of the request.  2. UTF-8 encode the *secret* corresponding to the API key, and call it &#x60;Key&#x60;.  3. UTF-8 encode the string &#x60;s&#x60;, and call it &#x60;Data&#x60;.  4. Calculate the HMAC-SHA256 signature using &#x60;Key&#x60; and &#x60;Data&#x60;, and call it &#x60;H&#x60;.  5. Base64-encode &#x60;H&#x60;. The result is the signature of the request.  Signature Audits - -- -- -- -- -- -- -- -- --  Signatures are audited. If too many failed signature attempts are received in a row from a given remote endpoint, that endpoint will be temporarily blocked from further attempts. Error message will contain a timestamp when new attempts can be made. If continuing failing, a remote endpoint may become permanently blocked from accessing the API.  Alternative Name Suggestions - -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  If unable to create an account, suggestions for alternative account names will be returned as HTTP headers, with header names &#x60;X-AlternativeNameN&#x60;, where N is a random number starting with &#x60;1&#x60;. Digits will be two or more digits. 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAccountBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateAccountResponse)</returns>
        public async System.Threading.Tasks.Task<TAG.Networking.Agent.Client.ApiResponse<CreateAccountResponse>> CreateAccountWithHttpInfoAsync(CreateAccountBody createAccountBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'createAccountBody' is set
            if (createAccountBody == null)
            {
                throw new TAG.Networking.Agent.Client.ApiException(400, "Missing required parameter 'createAccountBody' when calling AccountApi->CreateAccount");
            }


            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createAccountBody;

            localVarRequestOptions.Operation = "AccountApi.CreateAccount";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CreateAccountResponse>("/Agent/Account/Create", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateAccount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Domain Info Gets human-readable information about the domain of the server. The request can be made anonymously. No authentication is  required. This resource is typically called in the beginning of an on-boarding process,  where the user is given a choice to select service provider (i.e. domain). 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="acceptLanguage">The Accept-Language is used to select which language to use for human-readable strings returned. (optional, default to &quot;en&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DomainInfoResponse</returns>
        public DomainInfoResponse GetDomainInfo(string acceptLanguage = default(string), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.ApiResponse<DomainInfoResponse> localVarResponse = GetDomainInfoWithHttpInfo(acceptLanguage);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Domain Info Gets human-readable information about the domain of the server. The request can be made anonymously. No authentication is  required. This resource is typically called in the beginning of an on-boarding process,  where the user is given a choice to select service provider (i.e. domain). 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="acceptLanguage">The Accept-Language is used to select which language to use for human-readable strings returned. (optional, default to &quot;en&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DomainInfoResponse</returns>
        public TAG.Networking.Agent.Client.ApiResponse<DomainInfoResponse> GetDomainInfoWithHttpInfo(string acceptLanguage = default(string), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (acceptLanguage != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Language", TAG.Networking.Agent.Client.ClientUtils.ParameterToString(acceptLanguage)); // header parameter
            }

            localVarRequestOptions.Operation = "AccountApi.GetDomainInfo";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<DomainInfoResponse>("/Agent/Account/DomainInfo", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDomainInfo", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Domain Info Gets human-readable information about the domain of the server. The request can be made anonymously. No authentication is  required. This resource is typically called in the beginning of an on-boarding process,  where the user is given a choice to select service provider (i.e. domain). 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="acceptLanguage">The Accept-Language is used to select which language to use for human-readable strings returned. (optional, default to &quot;en&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DomainInfoResponse</returns>
        public async System.Threading.Tasks.Task<DomainInfoResponse> GetDomainInfoAsync(string acceptLanguage = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            TAG.Networking.Agent.Client.ApiResponse<DomainInfoResponse> localVarResponse = await GetDomainInfoWithHttpInfoAsync(acceptLanguage, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Domain Info Gets human-readable information about the domain of the server. The request can be made anonymously. No authentication is  required. This resource is typically called in the beginning of an on-boarding process,  where the user is given a choice to select service provider (i.e. domain). 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="acceptLanguage">The Accept-Language is used to select which language to use for human-readable strings returned. (optional, default to &quot;en&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DomainInfoResponse)</returns>
        public async System.Threading.Tasks.Task<TAG.Networking.Agent.Client.ApiResponse<DomainInfoResponse>> GetDomainInfoWithHttpInfoAsync(string acceptLanguage = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (acceptLanguage != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Language", TAG.Networking.Agent.Client.ClientUtils.ParameterToString(acceptLanguage)); // header parameter
            }

            localVarRequestOptions.Operation = "AccountApi.GetDomainInfo";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<DomainInfoResponse>("/Agent/Account/DomainInfo", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDomainInfo", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get newly created account created using a web form Allows the client to get session information about a newly created account, created using a web form, without having to provide user credentials again.
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GetSessionTokenResponse</returns>
        public GetSessionTokenResponse GetSessionToken(Object body = default(Object), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.ApiResponse<GetSessionTokenResponse> localVarResponse = GetSessionTokenWithHttpInfo(body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get newly created account created using a web form Allows the client to get session information about a newly created account, created using a web form, without having to provide user credentials again.
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GetSessionTokenResponse</returns>
        public TAG.Networking.Agent.Client.ApiResponse<GetSessionTokenResponse> GetSessionTokenWithHttpInfo(Object body = default(Object), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "AccountApi.GetSessionToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<GetSessionTokenResponse>("/Agent/Account/GetSessionToken", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSessionToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get newly created account created using a web form Allows the client to get session information about a newly created account, created using a web form, without having to provide user credentials again.
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetSessionTokenResponse</returns>
        public async System.Threading.Tasks.Task<GetSessionTokenResponse> GetSessionTokenAsync(Object body = default(Object), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            TAG.Networking.Agent.Client.ApiResponse<GetSessionTokenResponse> localVarResponse = await GetSessionTokenWithHttpInfoAsync(body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get newly created account created using a web form Allows the client to get session information about a newly created account, created using a web form, without having to provide user credentials again.
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetSessionTokenResponse)</returns>
        public async System.Threading.Tasks.Task<TAG.Networking.Agent.Client.ApiResponse<GetSessionTokenResponse>> GetSessionTokenWithHttpInfoAsync(Object body = default(Object), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "AccountApi.GetSessionToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<GetSessionTokenResponse>("/Agent/Account/GetSessionToken", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSessionToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Login 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LoginResponse</returns>
        public LoginResponse Login(LoginBody loginBody, int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.ApiResponse<LoginResponse> localVarResponse = LoginWithHttpInfo(loginBody);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Login 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LoginResponse</returns>
        public TAG.Networking.Agent.Client.ApiResponse<LoginResponse> LoginWithHttpInfo(LoginBody loginBody, int operationIndex = 0)
        {
            // verify the required parameter 'loginBody' is set
            if (loginBody == null)
            {
                throw new TAG.Networking.Agent.Client.ApiException(400, "Missing required parameter 'loginBody' when calling AccountApi->Login");
            }

            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = loginBody;

            localVarRequestOptions.Operation = "AccountApi.Login";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<LoginResponse>("/Agent/Account/Login", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Login", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Login 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LoginResponse</returns>
        public async System.Threading.Tasks.Task<LoginResponse> LoginAsync(LoginBody loginBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            TAG.Networking.Agent.Client.ApiResponse<LoginResponse> localVarResponse = await LoginWithHttpInfoAsync(loginBody, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Login 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LoginResponse)</returns>
        public async System.Threading.Tasks.Task<TAG.Networking.Agent.Client.ApiResponse<LoginResponse>> LoginWithHttpInfoAsync(LoginBody loginBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'loginBody' is set
            if (loginBody == null)
            {
                throw new TAG.Networking.Agent.Client.ApiException(400, "Missing required parameter 'loginBody' when calling AccountApi->Login");
            }


            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = loginBody;

            localVarRequestOptions.Operation = "AccountApi.Login";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<LoginResponse>("/Agent/Account/Login", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Login", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            if (localVarResponse.StatusCode == 0)
                throw new ApiException(0, localVarResponse.ErrorText);

            return localVarResponse;
        }

        /// <summary>
        /// Logout 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        public Object Logout(Object body = default(Object), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.ApiResponse<Object> localVarResponse = LogoutWithHttpInfo(body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Logout 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        public TAG.Networking.Agent.Client.ApiResponse<Object> LogoutWithHttpInfo(Object body = default(Object), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "AccountApi.Logout";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/Agent/Account/Logout", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Logout", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Logout 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> LogoutAsync(Object body = default(Object), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            TAG.Networking.Agent.Client.ApiResponse<Object> localVarResponse = await LogoutWithHttpInfoAsync(body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Logout 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<TAG.Networking.Agent.Client.ApiResponse<Object>> LogoutWithHttpInfoAsync(Object body = default(Object), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "AccountApi.Logout";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/Agent/Account/Logout", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Logout", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Recover Account 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recoverBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        public Object Recover(RecoverBody recoverBody = default(RecoverBody), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.ApiResponse<Object> localVarResponse = RecoverWithHttpInfo(recoverBody);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Recover Account 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recoverBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        public TAG.Networking.Agent.Client.ApiResponse<Object> RecoverWithHttpInfo(RecoverBody recoverBody = default(RecoverBody), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = recoverBody;

            localVarRequestOptions.Operation = "AccountApi.Recover";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/Agent/Account/Recover", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Recover", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Recover Account 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recoverBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> RecoverAsync(RecoverBody recoverBody = default(RecoverBody), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            TAG.Networking.Agent.Client.ApiResponse<Object> localVarResponse = await RecoverWithHttpInfoAsync(recoverBody, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Recover Account 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recoverBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<TAG.Networking.Agent.Client.ApiResponse<Object>> RecoverWithHttpInfoAsync(RecoverBody recoverBody = default(RecoverBody), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = recoverBody;

            localVarRequestOptions.Operation = "AccountApi.Recover";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/Agent/Account/Recover", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Recover", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Refresh 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="refreshBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LoginResponse</returns>
        public LoginResponse Refresh(RefreshBody refreshBody, int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.ApiResponse<LoginResponse> localVarResponse = RefreshWithHttpInfo(refreshBody);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Refresh 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="refreshBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LoginResponse</returns>
        public TAG.Networking.Agent.Client.ApiResponse<LoginResponse> RefreshWithHttpInfo(RefreshBody refreshBody, int operationIndex = 0)
        {
            // verify the required parameter 'refreshBody' is set
            if (refreshBody == null)
            {
                throw new TAG.Networking.Agent.Client.ApiException(400, "Missing required parameter 'refreshBody' when calling AccountApi->Refresh");
            }

            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = refreshBody;

            localVarRequestOptions.Operation = "AccountApi.Refresh";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<LoginResponse>("/Agent/Account/Refresh", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Refresh", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Refresh 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="refreshBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LoginResponse</returns>
        public async System.Threading.Tasks.Task<LoginResponse> RefreshAsync(RefreshBody refreshBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            TAG.Networking.Agent.Client.ApiResponse<LoginResponse> localVarResponse = await RefreshWithHttpInfoAsync(refreshBody, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Refresh 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="refreshBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LoginResponse)</returns>
        public async System.Threading.Tasks.Task<TAG.Networking.Agent.Client.ApiResponse<LoginResponse>> RefreshWithHttpInfoAsync(RefreshBody refreshBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'refreshBody' is set
            if (refreshBody == null)
            {
                throw new TAG.Networking.Agent.Client.ApiException(400, "Missing required parameter 'refreshBody' when calling AccountApi->Refresh");
            }


            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = refreshBody;

            localVarRequestOptions.Operation = "AccountApi.Refresh";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<LoginResponse>("/Agent/Account/Refresh", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Refresh", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Verify E-Mail 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="verifyEMailBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>VerifyEMailResponse</returns>
        public VerifyEMailResponse VerifyEMail(VerifyEMailBody verifyEMailBody, int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.ApiResponse<VerifyEMailResponse> localVarResponse = VerifyEMailWithHttpInfo(verifyEMailBody);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Verify E-Mail 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="verifyEMailBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of VerifyEMailResponse</returns>
        public TAG.Networking.Agent.Client.ApiResponse<VerifyEMailResponse> VerifyEMailWithHttpInfo(VerifyEMailBody verifyEMailBody, int operationIndex = 0)
        {
            // verify the required parameter 'verifyEMailBody' is set
            if (verifyEMailBody == null)
            {
                throw new TAG.Networking.Agent.Client.ApiException(400, "Missing required parameter 'verifyEMailBody' when calling AccountApi->VerifyEMail");
            }

            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = verifyEMailBody;

            localVarRequestOptions.Operation = "AccountApi.VerifyEMail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<VerifyEMailResponse>("/Agent/Account/VerifyEMail", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("VerifyEMail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Verify E-Mail 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="verifyEMailBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VerifyEMailResponse</returns>
        public async System.Threading.Tasks.Task<VerifyEMailResponse> VerifyEMailAsync(VerifyEMailBody verifyEMailBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            TAG.Networking.Agent.Client.ApiResponse<VerifyEMailResponse> localVarResponse = await VerifyEMailWithHttpInfoAsync(verifyEMailBody, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Verify E-Mail 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="verifyEMailBody"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VerifyEMailResponse)</returns>
        public async System.Threading.Tasks.Task<TAG.Networking.Agent.Client.ApiResponse<VerifyEMailResponse>> VerifyEMailWithHttpInfoAsync(VerifyEMailBody verifyEMailBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'verifyEMailBody' is set
            if (verifyEMailBody == null)
            {
                throw new TAG.Networking.Agent.Client.ApiException(400, "Missing required parameter 'verifyEMailBody' when calling AccountApi->VerifyEMail");
            }


            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = verifyEMailBody;

            localVarRequestOptions.Operation = "AccountApi.VerifyEMail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<VerifyEMailResponse>("/Agent/Account/VerifyEMail", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("VerifyEMail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Login 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="wwwLoginBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LoginResponse</returns>
        public LoginResponse WwwLogin(WwwLoginBody wwwLoginBody = default(WwwLoginBody), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.ApiResponse<LoginResponse> localVarResponse = WwwLoginWithHttpInfo(wwwLoginBody);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Login 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="wwwLoginBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LoginResponse</returns>
        public TAG.Networking.Agent.Client.ApiResponse<LoginResponse> WwwLoginWithHttpInfo(WwwLoginBody wwwLoginBody = default(WwwLoginBody), int operationIndex = 0)
        {
            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = wwwLoginBody;

            localVarRequestOptions.Operation = "AccountApi.WwwLogin";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (WwwAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + TAG.Networking.Agent.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<LoginResponse>("/Agent/Account/WwwLogin", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WwwLogin", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Login 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="wwwLoginBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LoginResponse</returns>
        public async System.Threading.Tasks.Task<LoginResponse> WwwLoginAsync(WwwLoginBody wwwLoginBody = default(WwwLoginBody), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            TAG.Networking.Agent.Client.ApiResponse<LoginResponse> localVarResponse = await WwwLoginWithHttpInfoAsync(wwwLoginBody, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Login 
        /// </summary>
        /// <exception cref="TAG.Networking.Agent.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="wwwLoginBody"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LoginResponse)</returns>
        public async System.Threading.Tasks.Task<TAG.Networking.Agent.Client.ApiResponse<LoginResponse>> WwwLoginWithHttpInfoAsync(WwwLoginBody wwwLoginBody = default(WwwLoginBody), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            TAG.Networking.Agent.Client.RequestOptions localVarRequestOptions = new TAG.Networking.Agent.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/xml",
                "text/plain"
            };

            var localVarContentType = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = TAG.Networking.Agent.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = wwwLoginBody;

            localVarRequestOptions.Operation = "AccountApi.WwwLogin";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (WwwAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + TAG.Networking.Agent.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<LoginResponse>("/Agent/Account/WwwLogin", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WwwLogin", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
